#![allow(
    path_statements,
    unused_imports,
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    unused_parens,
    non_shorthand_field_patterns,
    dead_code,
    overflowing_literals,
    unreachable_patterns,
    unused_variables,
    clippy::unknown_clippy_lints,
    clippy::missing_safety_doc,
    clippy::match_single_binding
)]

//use ::serde::de::DeserializeOwned;
use ::differential_datalog::record::FromRecord;
use ::differential_datalog::record::IntoRecord;
use ::differential_datalog::record::Mutator;
use ::serde::Deserialize;
use ::serde::Serialize;

// `usize` and `isize` are builtin Rust types; we therefore declare an alias to DDlog's `usize` and
// `isize`.
pub type std_usize = u64;
pub type std_isize = i64;

mod ddlog_log;
pub use ddlog_log::*;

pub mod closure;

/* FlatBuffers code generated by `flatc` */
#[cfg(feature = "flatbuf")]
mod flatbuf_generated;

/* `FromFlatBuffer`, `ToFlatBuffer`, etc, trait declarations. */
#[cfg(feature = "flatbuf")]
pub mod flatbuf;

pub trait Val:
    Default
    + Eq
    + Ord
    + Clone
    + ::std::hash::Hash
    + PartialEq
    + PartialOrd
    + Serialize
    + ::serde::de::DeserializeOwned
    + 'static
{
}

impl<T> Val for T where
    T: Default
        + Eq
        + Ord
        + Clone
        + ::std::hash::Hash
        + PartialEq
        + PartialOrd
        + Serialize
        + ::serde::de::DeserializeOwned
        + 'static
{
}

pub fn string_append_str(mut s1: String, s2: &str) -> String {
    s1.push_str(s2);
    s1
}

#[allow(clippy::ptr_arg)]
pub fn string_append(mut s1: String, s2: &String) -> String {
    s1.push_str(s2.as_str());
    s1
}

#[macro_export]
macro_rules! deserialize_map_from_array {
    ( $modname:ident, $ktype:ty, $vtype:ty, $kfunc:path ) => {
        mod $modname {
            use super::*;
            use serde::de::{Deserialize, Deserializer};
            use serde::ser::Serializer;
            use std::collections::BTreeMap;

            pub fn serialize<S>(
                map: &crate::ddlog_std::Map<$ktype, $vtype>,
                serializer: S,
            ) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                serializer.collect_seq(map.x.values())
            }

            pub fn deserialize<'de, D>(
                deserializer: D,
            ) -> Result<crate::ddlog_std::Map<$ktype, $vtype>, D::Error>
            where
                D: Deserializer<'de>,
            {
                let v = Vec::<$vtype>::deserialize(deserializer)?;
                Ok(v.into_iter().map(|item| ($kfunc(&item), item)).collect())
            }
        }
    };
}

pub mod ddlog_std;
pub mod debug;
pub mod internment;
pub mod log;
pub mod vec;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct Application {
    pub expr: crate::ExprId,
    pub func: crate::ExprId,
}
impl abomonation::Abomonation for Application {}
impl differential_datalog::record::FromRecord for Application {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Application" if _args.len() == 2 => Ok(crate::Application {
                        expr: <crate::ExprId>::from_record(&_args[0])?,
                        func: <crate::ExprId>::from_record(&_args[1])?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Application in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Application" => Ok(crate::Application {
                        expr: differential_datalog::record::arg_extract::<crate::ExprId>(
                            _args, "expr",
                        )?,
                        func: differential_datalog::record::arg_extract::<crate::ExprId>(
                            _args, "func",
                        )?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Application in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_struct_into_record!(Application["Application"]<>, expr, func);
::differential_datalog::decl_record_mutator_struct!(Application, <>, expr: crate::ExprId, func: crate::ExprId);
impl ::std::fmt::Display for Application {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::Application { expr, func } => {
                __formatter.write_str("Application{")?;
                ::std::fmt::Debug::fmt(expr, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(func, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for Application {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct ApplicationArg {
    pub expr: crate::ExprId,
    pub arg: crate::ExprId,
}
impl abomonation::Abomonation for ApplicationArg {}
impl differential_datalog::record::FromRecord for ApplicationArg {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "ApplicationArg" if _args.len() == 2 => Ok(crate::ApplicationArg {
                        expr: <crate::ExprId>::from_record(&_args[0])?,
                        arg: <crate::ExprId>::from_record(&_args[1])?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type ApplicationArg in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "ApplicationArg" => Ok(crate::ApplicationArg {
                        expr: differential_datalog::record::arg_extract::<crate::ExprId>(
                            _args, "expr",
                        )?,
                        arg: differential_datalog::record::arg_extract::<crate::ExprId>(
                            _args, "arg",
                        )?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type ApplicationArg in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_struct_into_record!(ApplicationArg["ApplicationArg"]<>, expr, arg);
::differential_datalog::decl_record_mutator_struct!(ApplicationArg, <>, expr: crate::ExprId, arg: crate::ExprId);
impl ::std::fmt::Display for ApplicationArg {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::ApplicationArg { expr, arg } => {
                __formatter.write_str("ApplicationArg{")?;
                ::std::fmt::Debug::fmt(expr, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(arg, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for ApplicationArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct ChildScope {
    pub parent: crate::Scope,
    pub child: crate::Scope,
}
impl abomonation::Abomonation for ChildScope {}
impl differential_datalog::record::FromRecord for ChildScope {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "ChildScope" if _args.len() == 2 => Ok(crate::ChildScope {
                        parent: <crate::Scope>::from_record(&_args[0])?,
                        child: <crate::Scope>::from_record(&_args[1])?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type ChildScope in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "ChildScope" => Ok(crate::ChildScope {
                        parent: differential_datalog::record::arg_extract::<crate::Scope>(
                            _args, "parent",
                        )?,
                        child: differential_datalog::record::arg_extract::<crate::Scope>(
                            _args, "child",
                        )?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type ChildScope in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_struct_into_record!(ChildScope["ChildScope"]<>, parent, child);
::differential_datalog::decl_record_mutator_struct!(ChildScope, <>, parent: crate::Scope, child: crate::Scope);
impl ::std::fmt::Display for ChildScope {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::ChildScope { parent, child } => {
                __formatter.write_str("ChildScope{")?;
                ::std::fmt::Debug::fmt(parent, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(child, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for ChildScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
pub type ExprId = u32;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum ExprKind {
    Var { v: crate::Ident },
    App,
    Decl,
    Lit,
}
impl abomonation::Abomonation for ExprKind {}
impl differential_datalog::record::FromRecord for ExprKind {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Var" if _args.len() == 1 => Ok(crate::ExprKind::Var {
                        v: <crate::Ident>::from_record(&_args[0])?,
                    }),
                    "App" if _args.is_empty() => Ok(crate::ExprKind::App {}),
                    "Decl" if _args.is_empty() => Ok(crate::ExprKind::Decl {}),
                    "Lit" if _args.is_empty() => Ok(crate::ExprKind::Lit {}),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type ExprKind in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Var" => Ok(crate::ExprKind::Var {
                        v: differential_datalog::record::arg_extract::<crate::Ident>(_args, "v")?,
                    }),
                    "App" => Ok(crate::ExprKind::App {}),
                    "Decl" => Ok(crate::ExprKind::Decl {}),
                    "Lit" => Ok(crate::ExprKind::Lit {}),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type ExprKind in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_enum_into_record!(ExprKind, <>, Var["Var"]{v}, App["App"]{}, Decl["Decl"]{}, Lit["Lit"]{});
::differential_datalog::decl_record_mutator_enum!(ExprKind, <>, Var{v: crate::Ident}, App{}, Decl{}, Lit{});
impl ::std::fmt::Display for ExprKind {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::ExprKind::Var { v } => {
                __formatter.write_str("Var{")?;
                ::std::fmt::Debug::fmt(v, __formatter)?;
                __formatter.write_str("}")
            }
            crate::ExprKind::App {} => {
                __formatter.write_str("App{")?;
                __formatter.write_str("}")
            }
            crate::ExprKind::Decl {} => {
                __formatter.write_str("Decl{")?;
                __formatter.write_str("}")
            }
            crate::ExprKind::Lit {} => {
                __formatter.write_str("Lit{")?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for ExprKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
impl ::std::default::Default for ExprKind {
    fn default() -> Self {
        crate::ExprKind::Var {
            v: ::std::default::Default::default(),
        }
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct Expression {
    pub id: crate::ExprId,
    pub func: crate::FuncId,
    pub kind: crate::ExprKind,
    pub scope: crate::Scope,
}
impl abomonation::Abomonation for Expression {}
impl differential_datalog::record::FromRecord for Expression {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Expression" if _args.len() == 4 => Ok(crate::Expression {
                        id: <crate::ExprId>::from_record(&_args[0])?,
                        func: <crate::FuncId>::from_record(&_args[1])?,
                        kind: <crate::ExprKind>::from_record(&_args[2])?,
                        scope: <crate::Scope>::from_record(&_args[3])?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Expression in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Expression" => Ok(crate::Expression {
                        id: differential_datalog::record::arg_extract::<crate::ExprId>(
                            _args, "id",
                        )?,
                        func: differential_datalog::record::arg_extract::<crate::FuncId>(
                            _args, "func",
                        )?,
                        kind: differential_datalog::record::arg_extract::<crate::ExprKind>(
                            _args, "kind",
                        )?,
                        scope: differential_datalog::record::arg_extract::<crate::Scope>(
                            _args, "scope",
                        )?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Expression in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_struct_into_record!(Expression["Expression"]<>, id, func, kind, scope);
::differential_datalog::decl_record_mutator_struct!(Expression, <>, id: crate::ExprId, func: crate::FuncId, kind: crate::ExprKind, scope: crate::Scope);
impl ::std::fmt::Display for Expression {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::Expression {
                id,
                func,
                kind,
                scope,
            } => {
                __formatter.write_str("Expression{")?;
                ::std::fmt::Debug::fmt(id, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(func, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(kind, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(scope, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for Expression {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct ExpressionType {
    pub expr: crate::ExprId,
    pub ty: crate::Type,
}
impl abomonation::Abomonation for ExpressionType {}
impl differential_datalog::record::FromRecord for ExpressionType {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "ExpressionType" if _args.len() == 2 => Ok(crate::ExpressionType {
                        expr: <crate::ExprId>::from_record(&_args[0])?,
                        ty: <crate::Type>::from_record(&_args[1])?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type ExpressionType in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "ExpressionType" => Ok(crate::ExpressionType {
                        expr: differential_datalog::record::arg_extract::<crate::ExprId>(
                            _args, "expr",
                        )?,
                        ty: differential_datalog::record::arg_extract::<crate::Type>(_args, "ty")?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type ExpressionType in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_struct_into_record!(ExpressionType["ExpressionType"]<>, expr, ty);
::differential_datalog::decl_record_mutator_struct!(ExpressionType, <>, expr: crate::ExprId, ty: crate::Type);
impl ::std::fmt::Display for ExpressionType {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::ExpressionType { expr, ty } => {
                __formatter.write_str("ExpressionType{")?;
                ::std::fmt::Debug::fmt(expr, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for ExpressionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct FuncArg {
    pub func: crate::FuncId,
    pub name: crate::Ident,
    pub ty: crate::Type,
}
impl abomonation::Abomonation for FuncArg {}
impl differential_datalog::record::FromRecord for FuncArg {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "FuncArg" if _args.len() == 3 => Ok(crate::FuncArg {
                        func: <crate::FuncId>::from_record(&_args[0])?,
                        name: <crate::Ident>::from_record(&_args[1])?,
                        ty: <crate::Type>::from_record(&_args[2])?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type FuncArg in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "FuncArg" => Ok(crate::FuncArg {
                        func: differential_datalog::record::arg_extract::<crate::FuncId>(
                            _args, "func",
                        )?,
                        name: differential_datalog::record::arg_extract::<crate::Ident>(
                            _args, "name",
                        )?,
                        ty: differential_datalog::record::arg_extract::<crate::Type>(_args, "ty")?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type FuncArg in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_struct_into_record!(FuncArg["FuncArg"]<>, func, name, ty);
::differential_datalog::decl_record_mutator_struct!(FuncArg, <>, func: crate::FuncId, name: crate::Ident, ty: crate::Type);
impl ::std::fmt::Display for FuncArg {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::FuncArg { func, name, ty } => {
                __formatter.write_str("FuncArg{")?;
                ::std::fmt::Debug::fmt(func, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(name, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for FuncArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
pub type FuncId = u32;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct Function {
    pub name: crate::Ident,
    pub id: crate::FuncId,
    pub scope: crate::Scope,
    pub ret: crate::ddlog_std::Option<crate::Type>,
}
impl abomonation::Abomonation for Function {}
impl differential_datalog::record::FromRecord for Function {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Function" if _args.len() == 4 => Ok(crate::Function {
                        name: <crate::Ident>::from_record(&_args[0])?,
                        id: <crate::FuncId>::from_record(&_args[1])?,
                        scope: <crate::Scope>::from_record(&_args[2])?,
                        ret: <crate::ddlog_std::Option<crate::Type>>::from_record(&_args[3])?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Function in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Function" => Ok(crate::Function {
                        name: differential_datalog::record::arg_extract::<crate::Ident>(
                            _args, "name",
                        )?,
                        id: differential_datalog::record::arg_extract::<crate::FuncId>(
                            _args, "id",
                        )?,
                        scope: differential_datalog::record::arg_extract::<crate::Scope>(
                            _args, "scope",
                        )?,
                        ret: differential_datalog::record::arg_extract::<
                            crate::ddlog_std::Option<crate::Type>,
                        >(_args, "ret")?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Function in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_struct_into_record!(Function["Function"]<>, name, id, scope, ret);
::differential_datalog::decl_record_mutator_struct!(Function, <>, name: crate::Ident, id: crate::FuncId, scope: crate::Scope, ret: crate::ddlog_std::Option<crate::Type>);
impl ::std::fmt::Display for Function {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::Function {
                name,
                id,
                scope,
                ret,
            } => {
                __formatter.write_str("Function{")?;
                ::std::fmt::Debug::fmt(name, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(id, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(scope, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(ret, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for Function {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
pub type Ident = crate::internment::istring;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct InputScope {
    pub parent: crate::Scope,
    pub child: crate::Scope,
}
impl abomonation::Abomonation for InputScope {}
impl differential_datalog::record::FromRecord for InputScope {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "InputScope" if _args.len() == 2 => Ok(crate::InputScope {
                        parent: <crate::Scope>::from_record(&_args[0])?,
                        child: <crate::Scope>::from_record(&_args[1])?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type InputScope in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "InputScope" => Ok(crate::InputScope {
                        parent: differential_datalog::record::arg_extract::<crate::Scope>(
                            _args, "parent",
                        )?,
                        child: differential_datalog::record::arg_extract::<crate::Scope>(
                            _args, "child",
                        )?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type InputScope in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_struct_into_record!(InputScope["InputScope"]<>, parent, child);
::differential_datalog::decl_record_mutator_struct!(InputScope, <>, parent: crate::Scope, child: crate::Scope);
impl ::std::fmt::Display for InputScope {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::InputScope { parent, child } => {
                __formatter.write_str("InputScope{")?;
                ::std::fmt::Debug::fmt(parent, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(child, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for InputScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum Lit {
    LitInt { i: crate::ddlog_std::s64 },
    LitBool { b: bool },
    LitStr { s: crate::internment::istring },
}
impl abomonation::Abomonation for Lit {}
impl differential_datalog::record::FromRecord for Lit {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "LitInt" if _args.len() == 1 => Ok(crate::Lit::LitInt {
                        i: <crate::ddlog_std::s64>::from_record(&_args[0])?,
                    }),
                    "LitBool" if _args.len() == 1 => Ok(crate::Lit::LitBool {
                        b: <bool>::from_record(&_args[0])?,
                    }),
                    "LitStr" if _args.len() == 1 => Ok(crate::Lit::LitStr {
                        s: <crate::internment::istring>::from_record(&_args[0])?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Lit in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "LitInt" => Ok(crate::Lit::LitInt {
                        i: differential_datalog::record::arg_extract::<crate::ddlog_std::s64>(
                            _args, "i",
                        )?,
                    }),
                    "LitBool" => Ok(crate::Lit::LitBool {
                        b: differential_datalog::record::arg_extract::<bool>(_args, "b")?,
                    }),
                    "LitStr" => Ok(crate::Lit::LitStr {
                        s: differential_datalog::record::arg_extract::<crate::internment::istring>(
                            _args, "s",
                        )?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Lit in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_enum_into_record!(Lit, <>, LitInt["LitInt"]{i}, LitBool["LitBool"]{b}, LitStr["LitStr"]{s});
::differential_datalog::decl_record_mutator_enum!(Lit, <>, LitInt{i: crate::ddlog_std::s64}, LitBool{b: bool}, LitStr{s: crate::internment::istring});
impl ::std::fmt::Display for Lit {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::Lit::LitInt { i } => {
                __formatter.write_str("LitInt{")?;
                ::std::fmt::Debug::fmt(i, __formatter)?;
                __formatter.write_str("}")
            }
            crate::Lit::LitBool { b } => {
                __formatter.write_str("LitBool{")?;
                ::std::fmt::Debug::fmt(b, __formatter)?;
                __formatter.write_str("}")
            }
            crate::Lit::LitStr { s } => {
                __formatter.write_str("LitStr{")?;
                ::std::fmt::Debug::fmt(s, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for Lit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
impl ::std::default::Default for Lit {
    fn default() -> Self {
        crate::Lit::LitInt {
            i: ::std::default::Default::default(),
        }
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct Literal {
    pub expr: crate::ExprId,
    pub lit: crate::Lit,
}
impl abomonation::Abomonation for Literal {}
impl differential_datalog::record::FromRecord for Literal {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Literal" if _args.len() == 2 => Ok(crate::Literal {
                        expr: <crate::ExprId>::from_record(&_args[0])?,
                        lit: <crate::Lit>::from_record(&_args[1])?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Literal in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Literal" => Ok(crate::Literal {
                        expr: differential_datalog::record::arg_extract::<crate::ExprId>(
                            _args, "expr",
                        )?,
                        lit: differential_datalog::record::arg_extract::<crate::Lit>(_args, "lit")?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Literal in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_struct_into_record!(Literal["Literal"]<>, expr, lit);
::differential_datalog::decl_record_mutator_struct!(Literal, <>, expr: crate::ExprId, lit: crate::Lit);
impl ::std::fmt::Display for Literal {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::Literal { expr, lit } => {
                __formatter.write_str("Literal{")?;
                ::std::fmt::Debug::fmt(expr, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(lit, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for Literal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
pub type Scope = u32;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum Type {
    Bool,
    Int,
    String,
    Unit,
    Unknown,
    Func {
        args: crate::ddlog_std::Vec<crate::Type>,
        ret: crate::ddlog_std::Ref<crate::Type>,
    },
}
impl abomonation::Abomonation for Type {}
impl differential_datalog::record::FromRecord for Type {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Bool" if _args.is_empty() => Ok(crate::Type::Bool {}),
                    "Int" if _args.is_empty() => Ok(crate::Type::Int {}),
                    "String" if _args.is_empty() => Ok(crate::Type::String {}),
                    "Unit" if _args.is_empty() => Ok(crate::Type::Unit {}),
                    "Unknown" if _args.is_empty() => Ok(crate::Type::Unknown {}),
                    "Func" if _args.len() == 2 => Ok(crate::Type::Func {
                        args: <crate::ddlog_std::Vec<crate::Type>>::from_record(&_args[0])?,
                        ret: <crate::ddlog_std::Ref<crate::Type>>::from_record(&_args[1])?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Type in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Bool" => Ok(crate::Type::Bool {}),
                    "Int" => Ok(crate::Type::Int {}),
                    "String" => Ok(crate::Type::String {}),
                    "Unit" => Ok(crate::Type::Unit {}),
                    "Unknown" => Ok(crate::Type::Unknown {}),
                    "Func" => Ok(crate::Type::Func {
                        args: differential_datalog::record::arg_extract::<
                            crate::ddlog_std::Vec<crate::Type>,
                        >(_args, "args")?,
                        ret: differential_datalog::record::arg_extract::<
                            crate::ddlog_std::Ref<crate::Type>,
                        >(_args, "ret")?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Type in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_enum_into_record!(Type, <>, Bool["Bool"]{}, Int["Int"]{}, String["String"]{}, Unit["Unit"]{}, Unknown["Unknown"]{}, Func["Func"]{args, ret});
::differential_datalog::decl_record_mutator_enum!(Type, <>, Bool{}, Int{}, String{}, Unit{}, Unknown{}, Func{args: crate::ddlog_std::Vec<crate::Type>, ret: crate::ddlog_std::Ref<crate::Type>});
impl ::std::fmt::Display for Type {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::Type::Bool {} => {
                __formatter.write_str("Bool{")?;
                __formatter.write_str("}")
            }
            crate::Type::Int {} => {
                __formatter.write_str("Int{")?;
                __formatter.write_str("}")
            }
            crate::Type::String {} => {
                __formatter.write_str("String{")?;
                __formatter.write_str("}")
            }
            crate::Type::Unit {} => {
                __formatter.write_str("Unit{")?;
                __formatter.write_str("}")
            }
            crate::Type::Unknown {} => {
                __formatter.write_str("Unknown{")?;
                __formatter.write_str("}")
            }
            crate::Type::Func { args, ret } => {
                __formatter.write_str("Func{")?;
                ::std::fmt::Debug::fmt(args, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(ret, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
impl ::std::default::Default for Type {
    fn default() -> Self {
        crate::Type::Bool {}
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct VarDecl {
    pub expr: crate::ExprId,
    pub name: crate::Ident,
    pub val: crate::ExprId,
}
impl abomonation::Abomonation for VarDecl {}
impl differential_datalog::record::FromRecord for VarDecl {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "VarDecl" if _args.len() == 3 => Ok(crate::VarDecl {
                        expr: <crate::ExprId>::from_record(&_args[0])?,
                        name: <crate::Ident>::from_record(&_args[1])?,
                        val: <crate::ExprId>::from_record(&_args[2])?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type VarDecl in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "VarDecl" => Ok(crate::VarDecl {
                        expr: differential_datalog::record::arg_extract::<crate::ExprId>(
                            _args, "expr",
                        )?,
                        name: differential_datalog::record::arg_extract::<crate::Ident>(
                            _args, "name",
                        )?,
                        val: differential_datalog::record::arg_extract::<crate::ExprId>(
                            _args, "val",
                        )?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type VarDecl in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_struct_into_record!(VarDecl["VarDecl"]<>, expr, name, val);
::differential_datalog::decl_record_mutator_struct!(VarDecl, <>, expr: crate::ExprId, name: crate::Ident, val: crate::ExprId);
impl ::std::fmt::Display for VarDecl {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::VarDecl { expr, name, val } => {
                __formatter.write_str("VarDecl{")?;
                ::std::fmt::Debug::fmt(expr, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(name, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(val, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for VarDecl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct Variable {
    pub scope: crate::Scope,
    pub name: crate::Ident,
    pub ty: crate::Type,
}
impl abomonation::Abomonation for Variable {}
impl differential_datalog::record::FromRecord for Variable {
    fn from_record(
        val: &differential_datalog::record::Record,
    ) -> ::std::result::Result<Self, String> {
        match val {
            differential_datalog::record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Variable" if _args.len() == 3 => Ok(crate::Variable {
                        scope: <crate::Scope>::from_record(&_args[0])?,
                        name: <crate::Ident>::from_record(&_args[1])?,
                        ty: <crate::Type>::from_record(&_args[2])?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Variable in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Variable" => Ok(crate::Variable {
                        scope: differential_datalog::record::arg_extract::<crate::Scope>(
                            _args, "scope",
                        )?,
                        name: differential_datalog::record::arg_extract::<crate::Ident>(
                            _args, "name",
                        )?,
                        ty: differential_datalog::record::arg_extract::<crate::Type>(_args, "ty")?,
                    }),
                    c => ::std::result::Result::Err(format!(
                        "unknown constructor {} of type Variable in {:?}",
                        c, *val
                    )),
                }
            }
            differential_datalog::record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                } else {
                    ::std::result::Result::Err(format!(
                        "unsupported serialization format '{}'",
                        format
                    ))
                }
            }
            v => ::std::result::Result::Err(format!("not a struct {:?}", *v)),
        }
    }
}
::differential_datalog::decl_struct_into_record!(Variable["Variable"]<>, scope, name, ty);
::differential_datalog::decl_record_mutator_struct!(Variable, <>, scope: crate::Scope, name: crate::Ident, ty: crate::Type);
impl ::std::fmt::Display for Variable {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            crate::Variable { scope, name, ty } => {
                __formatter.write_str("Variable{")?;
                ::std::fmt::Debug::fmt(scope, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(name, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for Variable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
pub fn type_of(lit: &crate::Lit) -> crate::Type {
    match (*lit) {
        crate::Lit::LitInt { i: _ } => (crate::Type::Int {}),
        crate::Lit::LitBool { b: _ } => (crate::Type::Bool {}),
        crate::Lit::LitStr { s: _ } => (crate::Type::String {}),
    }
}
