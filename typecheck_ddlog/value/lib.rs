#![allow(
    unused_imports,
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    unused_parens,
    non_shorthand_field_patterns,
    dead_code,
    overflowing_literals,
    unreachable_patterns,
    unused_variables,
    clippy::unknown_clippy_lints,
    clippy::missing_safety_doc
)]

use ::std::convert::TryFrom;
use ::std::ffi;
use ::std::fmt;
use ::std::hash::Hash;
use ::std::result;

use ::serde::Deserialize;
use ::serde::Serialize;

use ::differential_datalog::ddval::*;
use ::differential_datalog::int::*;
use ::differential_datalog::program::*;
use ::differential_datalog::record;
use ::differential_datalog::record::FromRecord;
use ::differential_datalog::record::IntoRecord;
use ::differential_datalog::record::RelIdentifier;
use ::differential_datalog::uint::*;

use ::fnv::FnvHashMap;
use ::once_cell::sync::Lazy;
use ::ordered_float::OrderedFloat;

use ::types::closure;

/* FlatBuffers bindings generated by `ddlog` */
#[cfg(feature = "flatbuf")]
pub mod flatbuf;

impl TryFrom<&RelIdentifier> for Relations {
    type Error = ();

    fn try_from(rel_id: &RelIdentifier) -> result::Result<Self, Self::Error> {
        match rel_id {
            RelIdentifier::RelName(rname) => Relations::try_from(rname.as_ref()),
            RelIdentifier::RelId(id) => Relations::try_from(*id),
        }
    }
}

pub mod Value {
    use super::*;
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Bitval32(pub u32);
    impl abomonation::Abomonation for __Bitval32 {}
    impl ::std::fmt::Display for __Bitval32 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for __Bitval32 {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<__Bitval32> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut __Bitval32) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {__Bitval32}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Tuple0__(pub ());
    impl abomonation::Abomonation for __Tuple0__ {}
    impl ::std::fmt::Display for __Tuple0__ {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for __Tuple0__ {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<__Tuple0__> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut __Tuple0__) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {__Tuple0__}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Tuple4____Bitval32_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval(
        pub  (
            u32,
            ::types::ddlog_std::Ref<::types::Type>,
            u32,
            ::types::internment::Intern<String>,
        ),
    );
    impl abomonation::Abomonation
        for __Tuple4____Bitval32_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval
    {
    }
    impl ::std::fmt::Display
        for __Tuple4____Bitval32_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval
    {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord
        for __Tuple4____Bitval32_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval
    {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl
        differential_datalog::record::Mutator<
            __Tuple4____Bitval32_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval,
        > for differential_datalog::record::Record
    {
        fn mutate(
            &self,
            v: &mut __Tuple4____Bitval32_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval,
        ) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {__Tuple4____Bitval32_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Tuple2____Bitval32_internment_Intern____Stringval(
        pub (u32, ::types::internment::Intern<String>),
    );
    impl abomonation::Abomonation for __Tuple2____Bitval32_internment_Intern____Stringval {}
    impl ::std::fmt::Display for __Tuple2____Bitval32_internment_Intern____Stringval {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord
        for __Tuple2____Bitval32_internment_Intern____Stringval
    {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<__Tuple2____Bitval32_internment_Intern____Stringval>
        for differential_datalog::record::Record
    {
        fn mutate(
            &self,
            v: &mut __Tuple2____Bitval32_internment_Intern____Stringval,
        ) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {__Tuple2____Bitval32_internment_Intern____Stringval}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Tuple3____Bitval32_internment_Intern____Stringval___Bitval32(
        pub (u32, ::types::internment::Intern<String>, u32),
    );
    impl abomonation::Abomonation for __Tuple3____Bitval32_internment_Intern____Stringval___Bitval32 {}
    impl ::std::fmt::Display for __Tuple3____Bitval32_internment_Intern____Stringval___Bitval32 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord
        for __Tuple3____Bitval32_internment_Intern____Stringval___Bitval32
    {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl
        differential_datalog::record::Mutator<
            __Tuple3____Bitval32_internment_Intern____Stringval___Bitval32,
        > for differential_datalog::record::Record
    {
        fn mutate(
            &self,
            v: &mut __Tuple3____Bitval32_internment_Intern____Stringval___Bitval32,
        ) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {__Tuple3____Bitval32_internment_Intern____Stringval___Bitval32}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Tuple4__ddlog_std_Vec__Type_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval(
        pub  (
            ::types::ddlog_std::Vec<::types::Type>,
            ::types::ddlog_std::Ref<::types::Type>,
            u32,
            ::types::internment::Intern<String>,
        ),
    );
    impl abomonation::Abomonation for __Tuple4__ddlog_std_Vec__Type_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval {}
    impl ::std::fmt::Display for __Tuple4__ddlog_std_Vec__Type_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for __Tuple4__ddlog_std_Vec__Type_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<__Tuple4__ddlog_std_Vec__Type_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut __Tuple4__ddlog_std_Vec__Type_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval ) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {__Tuple4__ddlog_std_Vec__Type_ddlog_std_Ref__Type___Bitval32_internment_Intern____Stringval}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Tuple2__internment_Intern____Stringval___Bitval32(
        pub (::types::internment::Intern<String>, u32),
    );
    impl abomonation::Abomonation for __Tuple2__internment_Intern____Stringval___Bitval32 {}
    impl ::std::fmt::Display for __Tuple2__internment_Intern____Stringval___Bitval32 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord
        for __Tuple2__internment_Intern____Stringval___Bitval32
    {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<__Tuple2__internment_Intern____Stringval___Bitval32>
        for differential_datalog::record::Record
    {
        fn mutate(
            &self,
            v: &mut __Tuple2__internment_Intern____Stringval___Bitval32,
        ) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {__Tuple2__internment_Intern____Stringval___Bitval32}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Tuple3__internment_Intern____Stringval___Bitval32___Bitval32(
        pub (::types::internment::Intern<String>, u32, u32),
    );
    impl abomonation::Abomonation for __Tuple3__internment_Intern____Stringval___Bitval32___Bitval32 {}
    impl ::std::fmt::Display for __Tuple3__internment_Intern____Stringval___Bitval32___Bitval32 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord
        for __Tuple3__internment_Intern____Stringval___Bitval32___Bitval32
    {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl
        differential_datalog::record::Mutator<
            __Tuple3__internment_Intern____Stringval___Bitval32___Bitval32,
        > for differential_datalog::record::Record
    {
        fn mutate(
            &self,
            v: &mut __Tuple3__internment_Intern____Stringval___Bitval32___Bitval32,
        ) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {__Tuple3__internment_Intern____Stringval___Bitval32___Bitval32}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Tuple5__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type(
        pub  (
            ::types::internment::Intern<String>,
            u32,
            u32,
            ::types::ddlog_std::Option<::types::Type>,
            ::types::ddlog_std::Ref<::types::Type>,
        ),
    );
    impl abomonation::Abomonation for __Tuple5__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type {}
    impl ::std::fmt::Display for __Tuple5__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for __Tuple5__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<__Tuple5__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut __Tuple5__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type ) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {__Tuple5__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Tuple6__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type_Type(
        pub  (
            ::types::internment::Intern<String>,
            u32,
            u32,
            ::types::ddlog_std::Option<::types::Type>,
            ::types::ddlog_std::Ref<::types::Type>,
            ::types::Type,
        ),
    );
    impl abomonation::Abomonation for __Tuple6__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type_Type {}
    impl ::std::fmt::Display for __Tuple6__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type_Type {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for __Tuple6__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type_Type {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<__Tuple6__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type_Type> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut __Tuple6__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type_Type ) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {__Tuple6__internment_Intern____Stringval___Bitval32___Bitval32_ddlog_std_Option__Type_ddlog_std_Ref__Type_Type}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct Application(pub ::types::Application);
    impl abomonation::Abomonation for Application {}
    impl ::std::fmt::Display for Application {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for Application {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<Application> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut Application) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {Application}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct ApplicationArg(pub ::types::ApplicationArg);
    impl abomonation::Abomonation for ApplicationArg {}
    impl ::std::fmt::Display for ApplicationArg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for ApplicationArg {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<ApplicationArg>
        for differential_datalog::record::Record
    {
        fn mutate(
            &self,
            v: &mut ApplicationArg,
        ) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {ApplicationArg}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct ChildScope(pub ::types::ChildScope);
    impl abomonation::Abomonation for ChildScope {}
    impl ::std::fmt::Display for ChildScope {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for ChildScope {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<ChildScope> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut ChildScope) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {ChildScope}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct Expression(pub ::types::Expression);
    impl abomonation::Abomonation for Expression {}
    impl ::std::fmt::Display for Expression {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for Expression {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<Expression> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut Expression) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {Expression}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct ExpressionType(pub ::types::ExpressionType);
    impl abomonation::Abomonation for ExpressionType {}
    impl ::std::fmt::Display for ExpressionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for ExpressionType {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<ExpressionType>
        for differential_datalog::record::Record
    {
        fn mutate(
            &self,
            v: &mut ExpressionType,
        ) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {ExpressionType}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct FuncArg(pub ::types::FuncArg);
    impl abomonation::Abomonation for FuncArg {}
    impl ::std::fmt::Display for FuncArg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for FuncArg {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<FuncArg> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut FuncArg) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {FuncArg}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct Function(pub ::types::Function);
    impl abomonation::Abomonation for Function {}
    impl ::std::fmt::Display for Function {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for Function {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<Function> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut Function) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {Function}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct InputScope(pub ::types::InputScope);
    impl abomonation::Abomonation for InputScope {}
    impl ::std::fmt::Display for InputScope {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for InputScope {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<InputScope> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut InputScope) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {InputScope}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct Literal(pub ::types::Literal);
    impl abomonation::Abomonation for Literal {}
    impl ::std::fmt::Display for Literal {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for Literal {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<Literal> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut Literal) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {Literal}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct VarDecl(pub ::types::VarDecl);
    impl abomonation::Abomonation for VarDecl {}
    impl ::std::fmt::Display for VarDecl {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for VarDecl {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<VarDecl> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut VarDecl) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {VarDecl}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct Variable(pub ::types::Variable);
    impl abomonation::Abomonation for Variable {}
    impl ::std::fmt::Display for Variable {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl differential_datalog::record::IntoRecord for Variable {
        fn into_record(self) -> differential_datalog::record::Record {
            self.0.into_record()
        }
    }
    impl differential_datalog::record::Mutator<Variable> for differential_datalog::record::Record {
        fn mutate(&self, v: &mut Variable) -> ::std::result::Result<(), ::std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    ::differential_datalog::decl_ddval_convert! {Variable}
}
impl TryFrom<&str> for Relations {
    type Error = ();
    fn try_from(rname: &str) -> ::std::result::Result<Self, Self::Error> {
        match rname {
            "Application" => Ok(Relations::Application),
            "ApplicationArg" => Ok(Relations::ApplicationArg),
            "ChildScope" => Ok(Relations::ChildScope),
            "Expression" => Ok(Relations::Expression),
            "ExpressionType" => Ok(Relations::ExpressionType),
            "FuncArg" => Ok(Relations::FuncArg),
            "Function" => Ok(Relations::Function),
            "INPUT_Application" => Ok(Relations::INPUT_Application),
            "INPUT_ApplicationArg" => Ok(Relations::INPUT_ApplicationArg),
            "INPUT_Expression" => Ok(Relations::INPUT_Expression),
            "INPUT_FuncArg" => Ok(Relations::INPUT_FuncArg),
            "INPUT_Function" => Ok(Relations::INPUT_Function),
            "INPUT_InputScope" => Ok(Relations::INPUT_InputScope),
            "INPUT_Literal" => Ok(Relations::INPUT_Literal),
            "INPUT_VarDecl" => Ok(Relations::INPUT_VarDecl),
            "InputScope" => Ok(Relations::InputScope),
            "Literal" => Ok(Relations::Literal),
            "VarDecl" => Ok(Relations::VarDecl),
            "Variable" => Ok(Relations::Variable),
            "__Null" => Ok(Relations::__Null),
            _ => Err(()),
        }
    }
}
impl Relations {
    pub fn is_output(&self) -> bool {
        match self {
            Relations::ChildScope => true,
            Relations::ExpressionType => true,
            Relations::INPUT_Application => true,
            Relations::INPUT_ApplicationArg => true,
            Relations::INPUT_Expression => true,
            Relations::INPUT_FuncArg => true,
            Relations::INPUT_Function => true,
            Relations::INPUT_InputScope => true,
            Relations::INPUT_Literal => true,
            Relations::INPUT_VarDecl => true,
            Relations::Variable => true,
            _ => false,
        }
    }
}
impl Relations {
    pub fn is_input(&self) -> bool {
        match self {
            Relations::Application => true,
            Relations::ApplicationArg => true,
            Relations::Expression => true,
            Relations::FuncArg => true,
            Relations::Function => true,
            Relations::InputScope => true,
            Relations::Literal => true,
            Relations::VarDecl => true,
            _ => false,
        }
    }
}
impl TryFrom<RelId> for Relations {
    type Error = ();
    fn try_from(rid: RelId) -> ::std::result::Result<Self, Self::Error> {
        match rid {
            0 => Ok(Relations::Application),
            1 => Ok(Relations::ApplicationArg),
            2 => Ok(Relations::ChildScope),
            3 => Ok(Relations::Expression),
            4 => Ok(Relations::ExpressionType),
            5 => Ok(Relations::FuncArg),
            6 => Ok(Relations::Function),
            7 => Ok(Relations::INPUT_Application),
            8 => Ok(Relations::INPUT_ApplicationArg),
            9 => Ok(Relations::INPUT_Expression),
            10 => Ok(Relations::INPUT_FuncArg),
            11 => Ok(Relations::INPUT_Function),
            12 => Ok(Relations::INPUT_InputScope),
            13 => Ok(Relations::INPUT_Literal),
            14 => Ok(Relations::INPUT_VarDecl),
            15 => Ok(Relations::InputScope),
            16 => Ok(Relations::Literal),
            17 => Ok(Relations::VarDecl),
            18 => Ok(Relations::Variable),
            19 => Ok(Relations::__Null),
            _ => Err(()),
        }
    }
}
pub fn relid2name(rid: RelId) -> Option<&'static str> {
    match rid {
        0 => Some(&"Application"),
        1 => Some(&"ApplicationArg"),
        2 => Some(&"ChildScope"),
        3 => Some(&"Expression"),
        4 => Some(&"ExpressionType"),
        5 => Some(&"FuncArg"),
        6 => Some(&"Function"),
        7 => Some(&"INPUT_Application"),
        8 => Some(&"INPUT_ApplicationArg"),
        9 => Some(&"INPUT_Expression"),
        10 => Some(&"INPUT_FuncArg"),
        11 => Some(&"INPUT_Function"),
        12 => Some(&"INPUT_InputScope"),
        13 => Some(&"INPUT_Literal"),
        14 => Some(&"INPUT_VarDecl"),
        15 => Some(&"InputScope"),
        16 => Some(&"Literal"),
        17 => Some(&"VarDecl"),
        18 => Some(&"Variable"),
        19 => Some(&"__Null"),
        _ => None,
    }
}
pub fn relid2cname(rid: RelId) -> Option<&'static ::std::ffi::CStr> {
    RELIDMAPC.get(&rid).copied()
}
/// A map of `RelId`s to their name as an `&'static str`
pub static RELIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Relations, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map =
            ::fnv::FnvHashMap::with_capacity_and_hasher(20, ::fnv::FnvBuildHasher::default());
        map.insert(Relations::Application, "Application");
        map.insert(Relations::ApplicationArg, "ApplicationArg");
        map.insert(Relations::ChildScope, "ChildScope");
        map.insert(Relations::Expression, "Expression");
        map.insert(Relations::ExpressionType, "ExpressionType");
        map.insert(Relations::FuncArg, "FuncArg");
        map.insert(Relations::Function, "Function");
        map.insert(Relations::INPUT_Application, "INPUT_Application");
        map.insert(Relations::INPUT_ApplicationArg, "INPUT_ApplicationArg");
        map.insert(Relations::INPUT_Expression, "INPUT_Expression");
        map.insert(Relations::INPUT_FuncArg, "INPUT_FuncArg");
        map.insert(Relations::INPUT_Function, "INPUT_Function");
        map.insert(Relations::INPUT_InputScope, "INPUT_InputScope");
        map.insert(Relations::INPUT_Literal, "INPUT_Literal");
        map.insert(Relations::INPUT_VarDecl, "INPUT_VarDecl");
        map.insert(Relations::InputScope, "InputScope");
        map.insert(Relations::Literal, "Literal");
        map.insert(Relations::VarDecl, "VarDecl");
        map.insert(Relations::Variable, "Variable");
        map.insert(Relations::__Null, "__Null");
        map
    });
/// A map of `RelId`s to their name as an `&'static CStr`
pub static RELIDMAPC: ::once_cell::sync::Lazy<::fnv::FnvHashMap<RelId, &'static ::std::ffi::CStr>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map =
            ::fnv::FnvHashMap::with_capacity_and_hasher(20, ::fnv::FnvBuildHasher::default());
        map.insert(
            0,
            ::std::ffi::CStr::from_bytes_with_nul(b"Application\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            1,
            ::std::ffi::CStr::from_bytes_with_nul(b"ApplicationArg\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            2,
            ::std::ffi::CStr::from_bytes_with_nul(b"ChildScope\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            3,
            ::std::ffi::CStr::from_bytes_with_nul(b"Expression\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            4,
            ::std::ffi::CStr::from_bytes_with_nul(b"ExpressionType\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            5,
            ::std::ffi::CStr::from_bytes_with_nul(b"FuncArg\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            6,
            ::std::ffi::CStr::from_bytes_with_nul(b"Function\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            7,
            ::std::ffi::CStr::from_bytes_with_nul(b"INPUT_Application\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            8,
            ::std::ffi::CStr::from_bytes_with_nul(b"INPUT_ApplicationArg\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            9,
            ::std::ffi::CStr::from_bytes_with_nul(b"INPUT_Expression\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            10,
            ::std::ffi::CStr::from_bytes_with_nul(b"INPUT_FuncArg\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            11,
            ::std::ffi::CStr::from_bytes_with_nul(b"INPUT_Function\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            12,
            ::std::ffi::CStr::from_bytes_with_nul(b"INPUT_InputScope\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            13,
            ::std::ffi::CStr::from_bytes_with_nul(b"INPUT_Literal\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            14,
            ::std::ffi::CStr::from_bytes_with_nul(b"INPUT_VarDecl\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            15,
            ::std::ffi::CStr::from_bytes_with_nul(b"InputScope\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            16,
            ::std::ffi::CStr::from_bytes_with_nul(b"Literal\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            17,
            ::std::ffi::CStr::from_bytes_with_nul(b"VarDecl\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            18,
            ::std::ffi::CStr::from_bytes_with_nul(b"Variable\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            19,
            ::std::ffi::CStr::from_bytes_with_nul(b"__Null\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map
    });
/// A map of input `Relations`s to their name as an `&'static str`
pub static INPUT_RELIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Relations, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map =
            ::fnv::FnvHashMap::with_capacity_and_hasher(8, ::fnv::FnvBuildHasher::default());
        map.insert(Relations::Application, "Application");
        map.insert(Relations::ApplicationArg, "ApplicationArg");
        map.insert(Relations::Expression, "Expression");
        map.insert(Relations::FuncArg, "FuncArg");
        map.insert(Relations::Function, "Function");
        map.insert(Relations::InputScope, "InputScope");
        map.insert(Relations::Literal, "Literal");
        map.insert(Relations::VarDecl, "VarDecl");
        map
    });
/// A map of output `Relations`s to their name as an `&'static str`
pub static OUTPUT_RELIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Relations, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map =
            ::fnv::FnvHashMap::with_capacity_and_hasher(11, ::fnv::FnvBuildHasher::default());
        map.insert(Relations::ChildScope, "ChildScope");
        map.insert(Relations::ExpressionType, "ExpressionType");
        map.insert(Relations::INPUT_Application, "INPUT_Application");
        map.insert(Relations::INPUT_ApplicationArg, "INPUT_ApplicationArg");
        map.insert(Relations::INPUT_Expression, "INPUT_Expression");
        map.insert(Relations::INPUT_FuncArg, "INPUT_FuncArg");
        map.insert(Relations::INPUT_Function, "INPUT_Function");
        map.insert(Relations::INPUT_InputScope, "INPUT_InputScope");
        map.insert(Relations::INPUT_Literal, "INPUT_Literal");
        map.insert(Relations::INPUT_VarDecl, "INPUT_VarDecl");
        map.insert(Relations::Variable, "Variable");
        map
    });
impl TryFrom<&str> for Indexes {
    type Error = ();
    fn try_from(iname: &str) -> ::std::result::Result<Self, Self::Error> {
        match iname {
            "__Null_by_none" => Ok(Indexes::__Null_by_none),
            _ => Err(()),
        }
    }
}
impl TryFrom<IdxId> for Indexes {
    type Error = ();
    fn try_from(iid: IdxId) -> ::core::result::Result<Self, Self::Error> {
        match iid {
            0 => Ok(Indexes::__Null_by_none),
            _ => Err(()),
        }
    }
}
pub fn indexid2name(iid: IdxId) -> Option<&'static str> {
    match iid {
        0 => Some(&"__Null_by_none"),
        _ => None,
    }
}
pub fn indexid2cname(iid: IdxId) -> Option<&'static ::std::ffi::CStr> {
    IDXIDMAPC.get(&iid).copied()
}
/// A map of `Indexes` to their name as an `&'static str`
pub static IDXIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Indexes, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map =
            ::fnv::FnvHashMap::with_capacity_and_hasher(1, ::fnv::FnvBuildHasher::default());
        map.insert(Indexes::__Null_by_none, "__Null_by_none");
        map
    });
/// A map of `IdxId`s to their name as an `&'static CStr`
pub static IDXIDMAPC: ::once_cell::sync::Lazy<::fnv::FnvHashMap<IdxId, &'static ::std::ffi::CStr>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map =
            ::fnv::FnvHashMap::with_capacity_and_hasher(1, ::fnv::FnvBuildHasher::default());
        map.insert(
            0,
            ::std::ffi::CStr::from_bytes_with_nul(b"__Null_by_none\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map
    });
pub fn relval_from_record(
    rel: Relations,
    _rec: &differential_datalog::record::Record,
) -> ::std::result::Result<DDValue, String> {
    match rel {
        Relations::Application => {
            Ok(Value::Application(<::types::Application>::from_record(_rec)?).into_ddvalue())
        }
        Relations::ApplicationArg => {
            Ok(Value::ApplicationArg(<::types::ApplicationArg>::from_record(_rec)?).into_ddvalue())
        }
        Relations::ChildScope => {
            Ok(Value::ChildScope(<::types::ChildScope>::from_record(_rec)?).into_ddvalue())
        }
        Relations::Expression => {
            Ok(Value::Expression(<::types::Expression>::from_record(_rec)?).into_ddvalue())
        }
        Relations::ExpressionType => {
            Ok(Value::ExpressionType(<::types::ExpressionType>::from_record(_rec)?).into_ddvalue())
        }
        Relations::FuncArg => {
            Ok(Value::FuncArg(<::types::FuncArg>::from_record(_rec)?).into_ddvalue())
        }
        Relations::Function => {
            Ok(Value::Function(<::types::Function>::from_record(_rec)?).into_ddvalue())
        }
        Relations::INPUT_Application => {
            Ok(Value::Application(<::types::Application>::from_record(_rec)?).into_ddvalue())
        }
        Relations::INPUT_ApplicationArg => {
            Ok(Value::ApplicationArg(<::types::ApplicationArg>::from_record(_rec)?).into_ddvalue())
        }
        Relations::INPUT_Expression => {
            Ok(Value::Expression(<::types::Expression>::from_record(_rec)?).into_ddvalue())
        }
        Relations::INPUT_FuncArg => {
            Ok(Value::FuncArg(<::types::FuncArg>::from_record(_rec)?).into_ddvalue())
        }
        Relations::INPUT_Function => {
            Ok(Value::Function(<::types::Function>::from_record(_rec)?).into_ddvalue())
        }
        Relations::INPUT_InputScope => {
            Ok(Value::InputScope(<::types::InputScope>::from_record(_rec)?).into_ddvalue())
        }
        Relations::INPUT_Literal => {
            Ok(Value::Literal(<::types::Literal>::from_record(_rec)?).into_ddvalue())
        }
        Relations::INPUT_VarDecl => {
            Ok(Value::VarDecl(<::types::VarDecl>::from_record(_rec)?).into_ddvalue())
        }
        Relations::InputScope => {
            Ok(Value::InputScope(<::types::InputScope>::from_record(_rec)?).into_ddvalue())
        }
        Relations::Literal => {
            Ok(Value::Literal(<::types::Literal>::from_record(_rec)?).into_ddvalue())
        }
        Relations::VarDecl => {
            Ok(Value::VarDecl(<::types::VarDecl>::from_record(_rec)?).into_ddvalue())
        }
        Relations::Variable => {
            Ok(Value::Variable(<::types::Variable>::from_record(_rec)?).into_ddvalue())
        }
        Relations::__Null => Ok(Value::__Tuple0__(<()>::from_record(_rec)?).into_ddvalue()),
    }
}
pub fn relkey_from_record(
    rel: Relations,
    _rec: &differential_datalog::record::Record,
) -> ::std::result::Result<DDValue, String> {
    match rel {
        _ => Err(format!("relation {:?} does not have a primary key", rel)),
    }
}
pub fn idxkey_from_record(
    idx: Indexes,
    _rec: &differential_datalog::record::Record,
) -> ::std::result::Result<DDValue, String> {
    match idx {
        Indexes::__Null_by_none => Ok(Value::__Tuple0__(<()>::from_record(_rec)?).into_ddvalue()),
    }
}
pub fn indexes2arrid(idx: Indexes) -> ArrId {
    match idx {
        Indexes::__Null_by_none => (19, 0),
    }
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Relations {
    Application = 0,
    ApplicationArg = 1,
    ChildScope = 2,
    Expression = 3,
    ExpressionType = 4,
    FuncArg = 5,
    Function = 6,
    INPUT_Application = 7,
    INPUT_ApplicationArg = 8,
    INPUT_Expression = 9,
    INPUT_FuncArg = 10,
    INPUT_Function = 11,
    INPUT_InputScope = 12,
    INPUT_Literal = 13,
    INPUT_VarDecl = 14,
    InputScope = 15,
    Literal = 16,
    VarDecl = 17,
    Variable = 18,
    __Null = 19,
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Indexes {
    __Null_by_none = 0,
}
